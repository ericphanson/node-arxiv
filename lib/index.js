// Generated by CoffeeScript 2.3.0
(function() {
  var coerceEntry, coerceIds, coerceQuery, coerceQueryKey, coerceQueryValue, key_map, makeUrl, request, search, unique, xml2js;

  request = require('request');

  xml2js = require('xml2js');

  makeUrl = function(query, max_results = 1000, ids, sort_by = 'submittedDate') {
    var url;
    url = `http://export.arxiv.org/api/query?sortBy=${sort_by}&max_results=${max_results}`;
    if (query) {
      url += `&search_query=${query}`;
    }
    if (ids) {
      url += `&id_list=${ids}`;
    }
    return url;
  };

  key_map = {
    author: 'au',
    q: 'all',
    title: 'ti',
    category: 'cat'
  };

  coerceQueryKey = function(key) {
    return key_map[key] || key;
  };

  coerceQueryValue = function(key, value) {
    var matched;
    if (key === 'au') {
      if (matched = value.match(/^(\w+).* (\w+)$/)) {
        return matched[2] + '_' + matched[1][0];
      } else {
        return value;
      }
    } else {
      return value;
    }
  };

  coerceQuery = function(query) {
    var k, querys, v;
    querys = [];
    for (k in query) {
      v = query[k];
      k = coerceQueryKey(k);
      v = coerceQueryValue(k, v);
      querys.push([k, v].join(':'));
    }
    return querys.join('+AND+');
  };

  coerceIds = function(ids = []) {
    return ids.join(',');
  };

  unique = function(a, k) {
    var a_, i, j, known, len;
    a_ = [];
    known = {};
    for (j = 0, len = a.length; j < len; j++) {
      i = a[j];
      if (!known[i[k]]) {
        known[i[k]] = true;
        a_.push(i);
      }
    }
    return a_;
  };

  coerceEntry = function(entry) {
    return {
      id: entry.id[0],
      updated: new Date(entry.updated[0]),
      published: new Date(entry.published[0]),
      title: entry.title[0].trim().replace(/\s+/g, ' '),
      summary: entry.summary[0].trim().replace(/\s+/g, ' '),
      links: entry.link.map(function(link) {
        return {
          href: link['$']['href'],
          title: link['$']['title']
        };
      }),
      authors: unique(entry.author.map(function(author) {
        return {
          name: author['name'][0]
        };
      }), 'name'),
      categories: entry.category.map(function(category) {
        return category['$']['term'];
      })
    };
  };

  search = function(query, cb, max_results, id_list) {
    console.log(makeUrl(coerceQuery(query), max_results, coerceIds(id_list)));
    return request.get(makeUrl(coerceQuery(query), max_results, coerceIds(id_list)), function(err, resp, data) {
      return xml2js.parseString(data, function(err, parsed) {
        var items, ref, ref1, total;
        if (err != null) {
          return cb(err);
        } else {
          items = parsed != null ? (ref = parsed.feed) != null ? (ref1 = ref.entry) != null ? ref1.map(coerceEntry) : void 0 : void 0 : void 0;
          items || (items = []);
          total = Number(parsed.feed['opensearch:totalResults'][0]['_']);
          total || (total = 0);
          return cb(err, {items, total});
        }
      });
    });
  };

  module.exports = {search};

}).call(this);
